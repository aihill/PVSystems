<HEAD><TITLE>HTML check log for PVSystems</TITLE></HEAD>

    <h3><font color="#008000" size=5><a name="top">Library check log</a> </font></h3>
<font color="#0000FF" size=3>TASKS<br></font><br>
<li>Regression testing
<li>Model structure testing
<li>Class coverage analysis
<li>Condition coverage analysis
<p>
<font color="#0000FF" size=3><a href="#stats">Statistics</a> </font>
<font color="#0000FF" size=3><a href="#class">Class coverage</a> </font>
<font color="#0000FF" size=3><a href="#coverage">Condition coverage</a></p> </font>
</p>
<font color="#0000FF" size=3><br><a name="top"><b>REGRESSION TEST RESULTS</a></b><br><br></font>
<p><li><b>PVSystems.Examples.Application.BuckOpen</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Application.Inverter1phOpen</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Application.Inverter1phOpenSynch</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Application.Inverter1phClosedSynch</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Application.PVInverter1ph</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Application.PVInverter1phSynch</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Application.USBBatteryConverter</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Verification.IdealCBSwitchValidation</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Verification.MPPTControllerValidation</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Verification.PLLValidation</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Verification.PVArrayValidation</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Verification.SignalPWMValidation</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p><li><b>PVSystems.Examples.Verification.SwitchingCPMValidation</b>:<font color="#008000" size=3> Validation ok</font>. <font color="#008000" size=3>Structural validation ok</font>.  <font color="#008000" size=3>Translation time validation ok</font>.</li></p>
<p>
<font color="#0000FF" size=3><a href="#top">Top of page</a></font>
<font color="#0000FF" size=3><a href="#class">Class coverage</a> </font>
<font color="#0000FF" size=3><a href="#coverage">Condition coverage</a></p> </font>
</p>
<font color="#0000FF" size=3><br><a name="stats"><b>STATISTICS</a></b><br><br></font>
26 tests performed on 13 test cases.<br>
All tests ok, validation of PVSystems, <font color="#008000" size=3><b>successful</b></font>.
<p>
<font color="#0000FF" size=3><a href="#top">Top of page</a></font>
<font color="#0000FF" size=3><a href="#stats">Statistics</a> </font>
<font color="#0000FF" size=3><a href="#coverage">Condition coverage</a></p> </font>
</p>
<font color="#0000FF" size=3><br><a name="class"><b>CLASS COVERAGE</a></b><br><br></font>
<p>36 of 50 classes are covered by the test suite. 14 classes are not covered.<br>
Of the not covered classes
<li>14 are models</li>
<br>

        Listing classes in <tt>PVSystems</tt></p>
        
<ul type=disc>

<li>package <b>UsersGuide</b><ul type=disc>
<li>package <b>References</b><ul type=disc></ul>
<li>package <b>ReleaseNotes</b><ul type=disc></ul></ul>

<li>package <b>Examples</b><ul type=disc>
<li>package <b>Application</b><ul type=disc>
<li>model <b>BuckOpen</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>Inverter1phOpen</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>Inverter1phOpenSynch</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>Inverter1phClosed</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>model <b>Inverter1phClosedSynch</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>PVInverter1ph</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>PVInverter1phSynch</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>USBBatteryConverter</b>, <font color="#008000" size=3> used 1 time.</li></font></ul>
<li>package <b>Verification</b><ul type=disc>
<li>model <b>IdealCBSwitchValidation</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>MPPTControllerValidation</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>ParkValidation</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>model <b>PLLValidation</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>PVArrayValidation</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>SignalPWMValidation</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>SwitchingCPMValidation</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>SimpleBatteryValidation</b>, <font color="#FF0000" size=3> not used.</li></font></ul></ul>

<li>package <b>Electrical</b><ul type=disc>
<li>model <b>IdealCBSwitch</b>, <font color="#008000" size=3> used 9 times.</li></font>
<li>model <b>SW1</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>model <b>SW2</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>model <b>SW3</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>model <b>CCM1</b>, <font color="#008000" size=3> used 12 times.</li></font>
<li>model <b>CCM2</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>model <b>CCM3</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>model <b>CCM4</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>model <b>CCM5</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>model <b>CCM_DCM1</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>model <b>CCM_DCM2</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>model <b>PVArray</b>, <font color="#008000" size=3> used 5 times.</li></font>
<li>model <b>SimpleBattery</b>,<font color="#FF0000" size=3> not used.</font><ul type=disc></ul>
<li>package <b>Assemblies</b><ul type=disc>
<li>model <b>HBridge</b>,<font color="#008000" size=3> used 5 times.</font><ul type=disc>
<li>model <b>SwitchModel</b>, <font color="#008000" size=3> used 10 times.</li></font></ul>
<li>model <b>HBridgeSwitched</b>, <font color="#008000" size=3> used 2 times.</li></font>
<li>model <b>BidirectionalBuckBoost</b>,<font color="#008000" size=3> used 1 time.</font><ul type=disc>
<li>model <b>SwitchModel</b>, <font color="#008000" size=3> used 2 times.</li></font></ul>
<li>model <b>CPMBidirectionalBuckBoost</b>, <font color="#008000" size=3> used 1 time.</li></font></ul>
<li>package <b>Interfaces</b><ul type=disc>
<li>model <b>BatteryInterface</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>model <b>SwitchNetworkInterface</b>, <font color="#008000" size=3> used 13 times.</li></font>
<li>model <b>TwoPort</b>, <font color="#008000" size=3> used 22 times.</li></font></ul></ul>

<li>package <b>Control</b><ul type=disc>
<li>block <b>SwitchingPWM</b>, <font color="#008000" size=3> used 4 times.</li></font>
<li>block <b>SwitchingCPM</b>, <font color="#008000" size=3> used 1 time.</li></font>
<li>block <b>DeadTime</b>, <font color="#008000" size=3> used 2 times.</li></font>
<li>model <b>CPM_CCM</b>, <font color="#008000" size=3> used 2 times.</li></font>
<li>model <b>CPM</b>, <font color="#FF0000" size=3> not used.</li></font>
<li>block <b>Park</b>, <font color="#008000" size=3> used 8 times.</li></font>
<li>block <b>InversePark</b>, <font color="#008000" size=3> used 3 times.</li></font>
<li>block <b>PLL</b>, <font color="#008000" size=3> used 5 times.</li></font>
<li>block <b>MPPTController</b>, <font color="#008000" size=3> used 3 times.</li></font>
<li>package <b>Assemblies</b><ul type=disc>
<li>block <b>Inverter1phCurrentController</b>, <font color="#008000" size=3> used 3 times.</li></font>
<li>block <b>Inverter1phCompleteController</b>, <font color="#008000" size=3> used 2 times.</li></font></ul>
<li>package <b>Interfaces</b><ul type=disc>
<li>model <b>CPMInterface</b>, <font color="#008000" size=3> used 2 times.</li></font></ul></ul>

<li>package <b>Icons</b><ul type=disc></ul>
</ul>
<p>
<font color="#0000FF" size=3><a href="#top">Top of page</a></font>
<font color="#0000FF" size=3><a href="#stats">Statistics</a> </font>
<font color="#0000FF" size=3><a href="#class">Class coverage</a> </font>
</p>
<font color="#0000FF" size=3><br><a name="coverage"><b>CONDITION COVERAGE</a></b><br><br></font>
<p><ul type=disc>
<li><tt> not (PV.v < 0) and PV.v > PV.Vocn</tt> is always <b>false</b></li>
<li><tt> not (pVArray1.v < 0) and pVArray1.v > pVArray1.Vocn</tt> is always <b>false</b></li>
<li><tt> not HBsw.idealCBSwitch.idealClosingSwitch.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not HBsw.idealCBSwitch.idealDiode.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not HBsw.idealCBSwitch1.idealClosingSwitch.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not HBsw.idealCBSwitch1.idealDiode.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not HBsw.idealCBSwitch2.idealClosingSwitch.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not HBsw.idealCBSwitch2.idealDiode.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not HBsw.idealCBSwitch3.idealClosingSwitch.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not HBsw.idealCBSwitch3.idealDiode.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not R.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not Rav.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not Rbatt.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not Rdc.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not Rload.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not Rsw.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not conv.conv.inESR.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not conv.conv.outESR.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not conv.conv.resistor.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not dsw.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not idealCBSwitch.idealClosingSwitch.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not idealCBSwitch.idealDiode.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not mean.yGreaterOrEqualZero in when(sample(mean.t0+1/mean.f, 1/mean.f))</tt> is always <b>true</b></li>
<li><tt> not resistor.useHeatPort</tt> is always <b>true</b></li>
<li><tt> not sw.useHeatPort</tt> is always <b>true</b></li>
<li><tt>Controller.currentController.idPI.initType == Modelica.Blocks.Types.InitPID.InitialOutput and (Controller.currentController.idPI.y_start < Controller.currentController.idPI.yMin or Controller.currentController.idPI.y_start > Controller.currentController.idPI.yMax)</tt> is always <b>false</b></li>
<li><tt>Controller.currentController.idPI.limiter.strict</tt> is always <b>false</b></li>
<li><tt>Controller.currentController.iqPI.initType == Modelica.Blocks.Types.InitPID.InitialOutput and (Controller.currentController.iqPI.y_start < Controller.currentController.iqPI.yMin or Controller.currentController.iqPI.y_start > Controller.currentController.iqPI.yMax)</tt> is always <b>false</b></li>
<li><tt>Controller.currentController.iqPI.limiter.strict</tt> is always <b>false</b></li>
<li><tt>Controller.vdcPI.initType == Modelica.Blocks.Types.InitPID.InitialOutput and (Controller.vdcPI.y_start < Controller.vdcPI.yMin or Controller.vdcPI.y_start > Controller.vdcPI.yMax)</tt> is always <b>false</b></li>
<li><tt>Controller.vdcPI.limiter.strict</tt> is always <b>false</b></li>
<li><tt>PV.v < 0</tt> is always <b>false</b></li>
<li><tt>PWM.limiter.strict</tt> is always <b>false</b></li>
<li><tt>abs(controller.pk-pre(controller.pk)) < controller.pkThreshold in when(sample(controller.sampleTime, controller.sampleTime))</tt> is always <b>false</b></li>
<li><tt>boostPI.initType == Modelica.Blocks.Types.InitPID.InitialOutput and (boostPI.y_start < boostPI.yMin or boostPI.y_start > boostPI.yMax)</tt> is always <b>false</b></li>
<li><tt>boostPI.limiter.strict</tt> is always <b>false</b></li>
<li><tt>buckPI.initType == Modelica.Blocks.Types.InitPID.InitialOutput and (buckPI.y_start < buckPI.yMin or buckPI.y_start > buckPI.yMax)</tt> is always <b>false</b></li>
<li><tt>buckPI.limiter.strict</tt> is always <b>false</b></li>
<li><tt>control.idPI.initType == Modelica.Blocks.Types.InitPID.InitialOutput and (control.idPI.y_start < control.idPI.yMin or control.idPI.y_start > control.idPI.yMax)</tt> is always <b>false</b></li>
<li><tt>control.idPI.limiter.strict</tt> is always <b>false</b></li>
<li><tt>control.iqPI.initType == Modelica.Blocks.Types.InitPID.InitialOutput and (control.iqPI.y_start < control.iqPI.yMin or control.iqPI.y_start > control.iqPI.yMax)</tt> is always <b>false</b></li>
<li><tt>control.iqPI.limiter.strict</tt> is always <b>false</b></li>
<li><tt>controller.currentController.idPI.initType == Modelica.Blocks.Types.InitPID.InitialOutput and (controller.currentController.idPI.y_start < controller.currentController.idPI.yMin or controller.currentController.idPI.y_start > controller.currentController.idPI.yMax)</tt> is always <b>false</b></li>
<li><tt>controller.currentController.idPI.limiter.strict</tt> is always <b>false</b></li>
<li><tt>controller.currentController.iqPI.initType == Modelica.Blocks.Types.InitPID.InitialOutput and (controller.currentController.iqPI.y_start < controller.currentController.iqPI.yMin or controller.currentController.iqPI.y_start > controller.currentController.iqPI.yMax)</tt> is always <b>false</b></li>
<li><tt>controller.currentController.iqPI.limiter.strict</tt> is always <b>false</b></li>
<li><tt>controller.vdcPI.initType == Modelica.Blocks.Types.InitPID.InitialOutput and (controller.vdcPI.y_start < controller.vdcPI.yMin or controller.vdcPI.y_start > controller.vdcPI.yMax)</tt> is always <b>false</b></li>
<li><tt>controller.vdcPI.limiter.strict</tt> is always <b>false</b></li>
<li><tt>conv.boost_cpm.enable</tt> is always <b>false</b></li>
<li><tt>conv.buck_cpm.enable</tt> is always <b>true</b></li>
<li><tt>noEvent( not (abs(Controller.mppt.pk-pre(Controller.mppt.pk)) < Controller.mppt.pkThreshold) and  not (Controller.mppt.pk-pre(Controller.mppt.pk) > 0) and Controller.mppt.vk-pre(Controller.mppt.vk) > 0) in when(sample(Controller.mppt.sampleTime, Controller.mppt.sampleTime))</tt> is always <b>false</b></li>
<li><tt>noEvent( not (abs(Controller.mppt.pk-pre(Controller.mppt.pk)) < Controller.mppt.pkThreshold) and Controller.mppt.pk-pre(Controller.mppt.pk) > 0 and  not (Controller.mppt.vk-pre(Controller.mppt.vk) > 0) and Controller.mppt.vk-pre(Controller.mppt.vk) < 0) in when(sample(Controller.mppt.sampleTime, Controller.mppt.sampleTime))</tt> is always <b>false</b></li>
<li><tt>noEvent( not (abs(controller.mppt.pk-pre(controller.mppt.pk)) < controller.mppt.pkThreshold) and  not (controller.mppt.pk-pre(controller.mppt.pk) > 0) and  not (controller.mppt.vk-pre(controller.mppt.vk) > 0) and controller.mppt.vk-pre(controller.mppt.vk) < 0) in when(sample(controller.mppt.sampleTime, controller.mppt.sampleTime))</tt> is always <b>false</b></li>
<li><tt>noEvent( not (abs(controller.mppt.pk-pre(controller.mppt.pk)) < controller.mppt.pkThreshold) and  not (controller.mppt.pk-pre(controller.mppt.pk) > 0) and controller.mppt.vk-pre(controller.mppt.vk) > 0) in when(sample(controller.mppt.sampleTime, controller.mppt.sampleTime))</tt> is always <b>false</b></li>
<li><tt>noEvent( not (abs(controller.mppt.pk-pre(controller.mppt.pk)) < controller.mppt.pkThreshold) and controller.mppt.pk-pre(controller.mppt.pk) > 0 and  not (controller.mppt.vk-pre(controller.mppt.vk) > 0) and controller.mppt.vk-pre(controller.mppt.vk) < 0) in when(sample(controller.mppt.sampleTime, controller.mppt.sampleTime))</tt> is always <b>false</b></li>
<li><tt>pVArray1.v < 0</tt> is always <b>false</b></li>
<li><tt>signalPWM.limiter.strict</tt> is always <b>false</b></li>
<li><tt>smooth((if Controller.currentController.idPI.limiter.u > Controller.currentController.idPI.limiter.uMax then Controller.currentController.idPI.limiter.uMax else (if Controller.currentController.idPI.limiter.u < Controller.currentController.idPI.limiter.uMin then Controller.currentController.idPI.limiter.uMin else Controller.currentController.idPI.limiter.u)),  not Controller.currentController.i...</tt> is always <b>false</b></li>
<li><tt>smooth((if Controller.currentController.iqPI.limiter.u > Controller.currentController.iqPI.limiter.uMax then Controller.currentController.iqPI.limiter.uMax else (if Controller.currentController.iqPI.limiter.u < Controller.currentController.iqPI.limiter.uMin then Controller.currentController.iqPI.limiter.uMin else Controller.currentController.iqPI.limiter.u)),  not Controller.currentController.i...</tt> is always <b>false</b></li>
<li><tt>smooth((if Controller.vdcPI.limiter.u > Controller.vdcPI.limiter.uMax then Controller.vdcPI.limiter.uMax else (if Controller.vdcPI.limiter.u < Controller.vdcPI.limiter.uMin then Controller.vdcPI.limiter.uMin else Controller.vdcPI.limiter.u)),  not Controller.vdcPI.limiter.strict and Controller.vdcPI.limiter.u > Controller.vdcPI.limiter.uMax)</tt> is always <b>false</b></li>
<li><tt>smooth((if PWM.limiter.u > PWM.limiter.uMax then PWM.limiter.uMax else (if PWM.limiter.u < PWM.limiter.uMin then PWM.limiter.uMin else PWM.limiter.u)),  not PWM.limiter.strict and  not (PWM.limiter.u > PWM.limiter.uMax) and PWM.limiter.u < PWM.limiter.uMin)</tt> is always <b>false</b></li>
<li><tt>smooth((if PWM.limiter.u > PWM.limiter.uMax then PWM.limiter.uMax else (if PWM.limiter.u < PWM.limiter.uMin then PWM.limiter.uMin else PWM.limiter.u)),  not PWM.limiter.strict and PWM.limiter.u > PWM.limiter.uMax)</tt> is always <b>false</b></li>
<li><tt>smooth((if boostPI.limiter.u > boostPI.limiter.uMax then boostPI.limiter.uMax else (if boostPI.limiter.u < boostPI.limiter.uMin then boostPI.limiter.uMin else boostPI.limiter.u)),  not boostPI.limiter.strict and  not (boostPI.limiter.u > boostPI.limiter.uMax) and boostPI.limiter.u < boostPI.limiter.uMin)</tt> is always <b>false</b></li>
<li><tt>smooth((if boostPI.limiter.u > boostPI.limiter.uMax then boostPI.limiter.uMax else (if boostPI.limiter.u < boostPI.limiter.uMin then boostPI.limiter.uMin else boostPI.limiter.u)),  not boostPI.limiter.strict and boostPI.limiter.u > boostPI.limiter.uMax)</tt> is always <b>true</b></li>
<li><tt>smooth((if buckPI.limiter.u > buckPI.limiter.uMax then buckPI.limiter.uMax else (if buckPI.limiter.u < buckPI.limiter.uMin then buckPI.limiter.uMin else buckPI.limiter.u)),  not buckPI.limiter.strict and  not (buckPI.limiter.u > buckPI.limiter.uMax) and buckPI.limiter.u < buckPI.limiter.uMin)</tt> is always <b>false</b></li>
<li><tt>smooth((if buckPI.limiter.u > buckPI.limiter.uMax then buckPI.limiter.uMax else (if buckPI.limiter.u < buckPI.limiter.uMin then buckPI.limiter.uMin else buckPI.limiter.u)),  not buckPI.limiter.strict and buckPI.limiter.u > buckPI.limiter.uMax)</tt> is always <b>false</b></li>
<li><tt>smooth((if control.idPI.limiter.u > control.idPI.limiter.uMax then control.idPI.limiter.uMax else (if control.idPI.limiter.u < control.idPI.limiter.uMin then control.idPI.limiter.uMin else control.idPI.limiter.u)),  not control.idPI.limiter.strict and  not (control.idPI.limiter.u > control.idPI.limiter.uMax) and control.idPI.limiter.u < control.idPI.limiter.uMin)</tt> is always <b>false</b></li>
<li><tt>smooth((if control.idPI.limiter.u > control.idPI.limiter.uMax then control.idPI.limiter.uMax else (if control.idPI.limiter.u < control.idPI.limiter.uMin then control.idPI.limiter.uMin else control.idPI.limiter.u)),  not control.idPI.limiter.strict and control.idPI.limiter.u > control.idPI.limiter.uMax)</tt> is always <b>false</b></li>
<li><tt>smooth((if control.iqPI.limiter.u > control.iqPI.limiter.uMax then control.iqPI.limiter.uMax else (if control.iqPI.limiter.u < control.iqPI.limiter.uMin then control.iqPI.limiter.uMin else control.iqPI.limiter.u)),  not control.iqPI.limiter.strict and  not (control.iqPI.limiter.u > control.iqPI.limiter.uMax) and control.iqPI.limiter.u < control.iqPI.limiter.uMin)</tt> is always <b>false</b></li>
<li><tt>smooth((if control.iqPI.limiter.u > control.iqPI.limiter.uMax then control.iqPI.limiter.uMax else (if control.iqPI.limiter.u < control.iqPI.limiter.uMin then control.iqPI.limiter.uMin else control.iqPI.limiter.u)),  not control.iqPI.limiter.strict and control.iqPI.limiter.u > control.iqPI.limiter.uMax)</tt> is always <b>false</b></li>
<li><tt>smooth((if controller.currentController.idPI.limiter.u > controller.currentController.idPI.limiter.uMax then controller.currentController.idPI.limiter.uMax else (if controller.currentController.idPI.limiter.u < controller.currentController.idPI.limiter.uMin then controller.currentController.idPI.limiter.uMin else controller.currentController.idPI.limiter.u)),  not controller.currentController.i...</tt> is always <b>false</b></li>
<li><tt>smooth((if controller.vdcPI.limiter.u > controller.vdcPI.limiter.uMax then controller.vdcPI.limiter.uMax else (if controller.vdcPI.limiter.u < controller.vdcPI.limiter.uMin then controller.vdcPI.limiter.uMin else controller.vdcPI.limiter.u)),  not controller.vdcPI.limiter.strict and  not (controller.vdcPI.limiter.u > controller.vdcPI.limiter.uMax) and controller.vdcPI.limiter.u < controller.vdc...</tt> is always <b>true</b></li>
<li><tt>smooth((if controller.vdcPI.limiter.u > controller.vdcPI.limiter.uMax then controller.vdcPI.limiter.uMax else (if controller.vdcPI.limiter.u < controller.vdcPI.limiter.uMin then controller.vdcPI.limiter.uMin else controller.vdcPI.limiter.u)),  not controller.vdcPI.limiter.strict and controller.vdcPI.limiter.u > controller.vdcPI.limiter.uMax)</tt> is always <b>false</b></li>
<li><tt>smooth((if signalPWM.limiter.u > signalPWM.limiter.uMax then signalPWM.limiter.uMax else (if signalPWM.limiter.u < signalPWM.limiter.uMin then signalPWM.limiter.uMin else signalPWM.limiter.u)),  not signalPWM.limiter.strict and  not (signalPWM.limiter.u > signalPWM.limiter.uMax) and signalPWM.limiter.u < signalPWM.limiter.uMin)</tt> is always <b>false</b></li>
<li><tt>smooth((if signalPWM.limiter.u > signalPWM.limiter.uMax then signalPWM.limiter.uMax else (if signalPWM.limiter.u < signalPWM.limiter.uMin then signalPWM.limiter.uMin else signalPWM.limiter.u)),  not signalPWM.limiter.strict and signalPWM.limiter.u > signalPWM.limiter.uMax)</tt> is always <b>false</b></li>
<li><tt>smooth((if switchingCPM.vcLimiter.u > switchingCPM.vcLimiter.uMax then switchingCPM.vcLimiter.uMax else (if switchingCPM.vcLimiter.u < switchingCPM.vcLimiter.uMin then switchingCPM.vcLimiter.uMin else switchingCPM.vcLimiter.u)),  not switchingCPM.vcLimiter.strict and  not (switchingCPM.vcLimiter.u > switchingCPM.vcLimiter.uMax) and switchingCPM.vcLimiter.u < switchingCPM.vcLimiter.uMin)</tt> is always <b>false</b></li>
<li><tt>smooth((if switchingCPM.vcLimiter.u > switchingCPM.vcLimiter.uMax then switchingCPM.vcLimiter.uMax else (if switchingCPM.vcLimiter.u < switchingCPM.vcLimiter.uMin then switchingCPM.vcLimiter.uMin else switchingCPM.vcLimiter.u)),  not switchingCPM.vcLimiter.strict and switchingCPM.vcLimiter.u > switchingCPM.vcLimiter.uMax)</tt> is always <b>false</b></li>
<li><tt>smooth((if switchingPWM.limiter.u > switchingPWM.limiter.uMax then switchingPWM.limiter.uMax else (if switchingPWM.limiter.u < switchingPWM.limiter.uMin then switchingPWM.limiter.uMin else switchingPWM.limiter.u)),  not switchingPWM.limiter.strict and  not (switchingPWM.limiter.u > switchingPWM.limiter.uMax) and switchingPWM.limiter.u < switchingPWM.limiter.uMin)</tt> is always <b>false</b></li>
<li><tt>smooth((if switchingPWM.limiter.u > switchingPWM.limiter.uMax then switchingPWM.limiter.uMax else (if switchingPWM.limiter.u < switchingPWM.limiter.uMin then switchingPWM.limiter.uMin else switchingPWM.limiter.u)),  not switchingPWM.limiter.strict and switchingPWM.limiter.u > switchingPWM.limiter.uMax)</tt> is always <b>false</b></li>
<li><tt>switchingCPM.vcLimiter.strict</tt> is always <b>false</b></li>
<li><tt>switchingPWM.limiter.strict</tt> is always <b>false</b></li>
<p><li><b>Modelica.Blocks.Continuous.Integrator</b><ul type=disc><li><tt> not (Controller.currentController.idPI.initType == Modelica.Blocks.Types.InitPID.SteadyState) and (Controller.currentController.idPI.initType == Modelica.Blocks.Types.InitPID.InitialState or Controller.currentController.idPI.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState)</tt> is always <b>true</b></li>
<li><tt> not (Controller.currentController.iqPI.initType == Modelica.Blocks.Types.InitPID.SteadyState) and (Controller.currentController.iqPI.initType == Modelica.Blocks.Types.InitPID.InitialState or Controller.currentController.iqPI.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState)</tt> is always <b>true</b></li>
<li><tt> not (Controller.vdcPI.initType == Modelica.Blocks.Types.InitPID.SteadyState) and (Controller.vdcPI.initType == Modelica.Blocks.Types.InitPID.InitialState or Controller.vdcPI.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState)</tt> is always <b>true</b></li>
<li><tt> not (boostPI.initType == Modelica.Blocks.Types.InitPID.SteadyState) and (boostPI.initType == Modelica.Blocks.Types.InitPID.InitialState or boostPI.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState)</tt> is always <b>true</b></li>
<li><tt> not (buckPI.initType == Modelica.Blocks.Types.InitPID.SteadyState) and (buckPI.initType == Modelica.Blocks.Types.InitPID.InitialState or buckPI.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState)</tt> is always <b>true</b></li>
<li><tt> not (control.idPI.initType == Modelica.Blocks.Types.InitPID.SteadyState) and (control.idPI.initType == Modelica.Blocks.Types.InitPID.InitialState or control.idPI.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState)</tt> is always <b>true</b></li>
<li><tt> not (control.iqPI.initType == Modelica.Blocks.Types.InitPID.SteadyState) and (control.iqPI.initType == Modelica.Blocks.Types.InitPID.InitialState or control.iqPI.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState)</tt> is always <b>true</b></li>
<li><tt> not (controller.currentController.idPI.initType == Modelica.Blocks.Types.InitPID.SteadyState) and (controller.currentController.idPI.initType == Modelica.Blocks.Types.InitPID.InitialState or controller.currentController.idPI.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState)</tt> is always <b>true</b></li>
<li><tt> not (controller.currentController.iqPI.initType == Modelica.Blocks.Types.InitPID.SteadyState) and (controller.currentController.iqPI.initType == Modelica.Blocks.Types.InitPID.InitialState or controller.currentController.iqPI.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState)</tt> is always <b>true</b></li>
<li><tt> not (controller.vdcPI.initType == Modelica.Blocks.Types.InitPID.SteadyState) and (controller.vdcPI.initType == Modelica.Blocks.Types.InitPID.InitialState or controller.vdcPI.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState)</tt> is always <b>true</b></li>
<li><tt>Controller.currentController.idPI.initType == Modelica.Blocks.Types.InitPID.SteadyState</tt> is always <b>false</b></li>
<li><tt>Controller.currentController.iqPI.initType == Modelica.Blocks.Types.InitPID.SteadyState</tt> is always <b>false</b></li>
<li><tt>Controller.vdcPI.initType == Modelica.Blocks.Types.InitPID.SteadyState</tt> is always <b>false</b></li>
<li><tt>boostPI.initType == Modelica.Blocks.Types.InitPID.SteadyState</tt> is always <b>false</b></li>
<li><tt>buckPI.initType == Modelica.Blocks.Types.InitPID.SteadyState</tt> is always <b>false</b></li>
<li><tt>control.idPI.initType == Modelica.Blocks.Types.InitPID.SteadyState</tt> is always <b>false</b></li>
<li><tt>control.iqPI.initType == Modelica.Blocks.Types.InitPID.SteadyState</tt> is always <b>false</b></li>
<li><tt>controller.currentController.idPI.initType == Modelica.Blocks.Types.InitPID.SteadyState</tt> is always <b>false</b></li>
<li><tt>controller.currentController.iqPI.initType == Modelica.Blocks.Types.InitPID.SteadyState</tt> is always <b>false</b></li>
<li><tt>controller.vdcPI.initType == Modelica.Blocks.Types.InitPID.SteadyState</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Blocks.Continuous.LimPID</b><ul type=disc><li><tt>limitsAtInit</tt> is always <b>true</b></li>
<li><tt>strict</tt> is always <b>false</b></li>
<li><tt>with_D</tt> is always <b>false</b></li>
<li><tt>with_I</tt> is always <b>true</b></li>
</ul></li></p>
<p><li><b>Modelica.Blocks.Logical.Pre</b><ul type=disc><li><tt>pre_u_start</tt> is always <b>true</b></li>
</ul></li></p>
<p><li><b>Modelica.Blocks.Logical.RSFlipFlop</b><ul type=disc><li><tt>Qini</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Blocks.Math.Mean</b><ul type=disc><li><tt>yGreaterOrEqualZero</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Blocks.Nonlinear.Limiter</b><ul type=disc><li><tt>limitsAtInit</tt> is always <b>true</b></li>
<li><tt>strict</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Blocks.Sources.BooleanExpression</b><ul type=disc><li><tt>y</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Blocks.Sources.BooleanStep</b><ul type=disc><li><tt>startValue</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Blocks.Sources.Cosine</b><ul type=disc><li><tt>time < startTime</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Blocks.Sources.SawTooth</b><ul type=disc><li><tt>time < startTime or nperiod == 0 or nperiod > 0 and count >= nperiod</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Blocks.Sources.Sine</b><ul type=disc><li><tt>time < startTime</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Electrical.Analog.Basic.Resistor</b><ul type=disc><li><tt>useHeatPort</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Electrical.Analog.Basic.VariableResistor</b><ul type=disc><li><tt>useHeatPort</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Electrical.Analog.Ideal.IdealClosingSwitch</b><ul type=disc><li><tt>useHeatPort</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>Modelica.Electrical.Analog.Ideal.IdealDiode</b><ul type=disc><li><tt>useHeatPort</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>PVSystems.Electrical.Assemblies.CPMBidirectionalBuckBoost</b><ul type=disc><li><tt>mode</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>PVSystems.Electrical.CCM_DCM1</b><ul type=disc><li><tt>smooth((if d > dmax then dmax else (if d < dmin then dmin else d)),  not (d > dmax) and d < dmin)</tt> is always <b>false</b></li>
<li><tt>smooth((if d > dmax then dmax else (if d < dmin then dmin else d)), d > dmax)</tt> is always <b>false</b></li>
</ul></li></p>
<p><li><b>PVSystems.Electrical.Interfaces.SwitchNetworkInterface</b><ul type=disc><li><tt>smooth((if HBav.s1.d > HBav.s1.dmax then HBav.s1.dmax else (if HBav.s1.d < HBav.s1.dmin then HBav.s1.dmin else HBav.s1.d)), HBav.s1.d > HBav.s1.dmax)</tt> is always <b>false</b></li>
<li><tt>smooth((if HBav.s2.d > HBav.s2.dmax then HBav.s2.dmax else (if HBav.s2.d < HBav.s2.dmin then HBav.s2.dmin else HBav.s2.d)), HBav.s2.d > HBav.s2.dmax)</tt> is always <b>false</b></li>
<li><tt>smooth((if conv.conv.boostSw.d > conv.conv.boostSw.dmax then conv.conv.boostSw.dmax else (if conv.conv.boostSw.d < conv.conv.boostSw.dmin then conv.conv.boostSw.dmin else conv.conv.boostSw.d)),  not (conv.conv.boostSw.d > conv.conv.boostSw.dmax) and conv.conv.boostSw.d < conv.conv.boostSw.dmin)</tt> is always <b>true</b></li>
<li><tt>smooth((if conv.conv.boostSw.d > conv.conv.boostSw.dmax then conv.conv.boostSw.dmax else (if conv.conv.boostSw.d < conv.conv.boostSw.dmin then conv.conv.boostSw.dmin else conv.conv.boostSw.d)), conv.conv.boostSw.d > conv.conv.boostSw.dmax)</tt> is always <b>false</b></li>
<li><tt>smooth((if conv.conv.buckSw.d > conv.conv.buckSw.dmax then conv.conv.buckSw.dmax else (if conv.conv.buckSw.d < conv.conv.buckSw.dmin then conv.conv.buckSw.dmin else conv.conv.buckSw.d)), conv.conv.buckSw.d > conv.conv.buckSw.dmax)</tt> is always <b>false</b></li>
<li><tt>smooth((if sn.d > sn.dmax then sn.dmax else (if sn.d < sn.dmin then sn.dmin else sn.d)),  not (sn.d > sn.dmax) and sn.d < sn.dmin)</tt> is always <b>false</b></li>
<li><tt>smooth((if sn.d > sn.dmax then sn.dmax else (if sn.d < sn.dmin then sn.dmin else sn.d)), sn.d > sn.dmax)</tt> is always <b>false</b></li>
</ul></p></ul>
<p>
<font color="#0000FF" size=3><a href="#top">Top of page</a></font>
<font color="#0000FF" size=3><a href="#stats">Statistics</a> </font>
<font color="#0000FF" size=3><a href="#class">Class coverage</a> </font>
<font color="#0000FF" size=3><a href="#coverage">Condition coverage</a></p> </font>
</p>
